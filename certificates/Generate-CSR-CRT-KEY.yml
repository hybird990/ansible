- name: Generate and Sign CSR on Windows CA Host
  hosts: 192.168.1.11
  gather_facts: no

  vars:
    country: "{{ country }}"
    state: "{{ state }}"
    city: "{{ city }}"
    organization: "{{ organization }}"
    unit: "{{ unit }}"
    common_name: "{{ common_name }}"
    san_dns:
      - "{{ san1 | default('') }}"
      - "{{ san2 | default('') }}"
    san_ips:
      - "{{ ip1 | default('') }}"
      - "{{ ip2 | default('') }}"
    inf_path: "C:\\temp\\csr_request.inf"
    csr_path: "C:\\temp\\csr_request.req"
    csr_copy_path: "C:\\temp\\copied_{{ common_name }}.req"
    crt_path: "C:\\temp\\{{ common_name }}.crt"
    pfx_path: "C:\\temp\\{{ common_name }}.pfx"
    pfx_password: "StrongPassword123!"  # Can be overridden via --extra-vars
    ca_name: "addns.vmware.local\\vmware-ADDNS-CA"
    cert_template: "webserver1"  # Change to a template that supports auto-issuance

  tasks:

    - name: Generate CSR using PowerShell
      win_shell: |
        $InfPath = "{{ inf_path }}"
        $CsrPath = "{{ csr_path }}"
        $Country = "{{ country }}"
        $State = "{{ state }}"
        $City = "{{ city }}"
        $Org = "{{ organization }}"
        $Unit = "{{ unit }}"
        $CN = "{{ common_name }}"
        $SanDNS = @()
        $SanIPS = @()

        {% for dns in san_dns %}
        if ("{{ dns }}") { $SanDNS += "{{ dns }}" }
        {% endfor %}
        {% for ip in san_ips %}
        if ("{{ ip }}") { $SanIPS += "{{ ip }}" }
        {% endfor %}

        if (-not (Test-Path "C:\\temp")) {
            New-Item -Path "C:\\temp" -ItemType Directory | Out-Null
        }

        $inf = @"
        [Version]
        Signature=`"$Windows NT$`"

        [NewRequest]
        Subject = `"C=$Country, ST=$State, L=$City, O=$Org, OU=$Unit, CN=$CN`"
        KeySpec = 1
        KeyLength = 2048
        Exportable = TRUE
        MachineKeySet = TRUE
        SMIME = FALSE
        PrivateKeyArchive = FALSE
        UserProtected = FALSE
        UseExistingKeySet = FALSE
        ProviderName = `"Microsoft RSA SChannel Cryptographic Provider`"
        ProviderType = 12
        RequestType = PKCS10
        KeyUsage = 0xa0

        [Extensions]
        2.5.29.17 = `"{text}`"
        "@

        foreach ($dns in $SanDNS) {
            $inf += "`n_continue_ = `"dns=$dns`""
        }
        foreach ($ip in $SanIPS) {
            $inf += "`n_continue_ = `"ipaddress=$ip`""
        }

        Set-Content -Path $InfPath -Value $inf -Encoding ASCII
        certreq -new $InfPath $CsrPath
        Copy-Item -Path $CsrPath -Destination "{{ csr_copy_path }}" -Force
      args:
        executable: powershell

    - name: Submit CSR and wait for certificate issuance
      win_shell: |
        $CsrPath = "{{ csr_path }}"
        $CertPath = "{{ crt_path }}"
        $CAName = "{{ ca_name }}"
        $Template = "{{ cert_template }}"

        # Submit the request
        $output = certreq -submit -config "$CAName" -attrib "CertificateTemplate=$Template" $CsrPath 2>&1

        if ($output -match "RequestId: (\d+)") {
            $RequestId = $matches[1]
            Write-Host "Request ID: $RequestId"
        } else {
            Write-Host "CSR submitted but response did not include Request ID. Output:"
            Write-Host $output
            exit 1
        }

        # Poll for certificate issuance
        $Issued = $false
        $Retries = 20
        $SleepSec = 30
        for ($i = 0; $i -lt $Retries; $i++) {
            $status = certutil -view -restrict "RequestID=$RequestId" -out RequestDisposition 2>&1
            if ($status -match "RequestDisposition: (\d+)") {
                $disp = [int]$matches[1]
                if ($disp -eq 0x20) {
                    $Issued = $true
                    break
                }
            }
            Start-Sleep -Seconds $SleepSec
        }

        if (-not $Issued) {
            Write-Host "Certificate was not issued within timeout. Exiting."
            exit 1
        }

        # Retrieve and save certificate
        certreq -retrieve $RequestId $CertPath

        # Accept the certificate into local store
        certreq -accept $CertPath
      args:
        executable: powershell

    - name: Export signed certificate and private key to PFX
      win_shell: |
        $SubjectMatch = "CN={{ common_name }}"
        $Cert = Get-ChildItem -Path Cert:\LocalMachine\My | Where-Object { $_.Subject -like "*$SubjectMatch*" } | Sort-Object NotBefore -Descending | Select-Object -First 1

        if (-not $Cert) {
            Write-Error "Certificate not found in local store for CN={{ common_name }}"
            exit 1
        }

        $pwd = ConvertTo-SecureString -String "{{ pfx_password }}" -Force -AsPlainText
        Export-PfxCertificate -Cert $Cert -FilePath "{{ pfx_path }}" -Password $pwd -Force
      args:
        executable: powershell
